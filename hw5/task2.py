def my_staticmethod(method):
    """
    По схеме с пары видим, что если просто определить метод
    внутри класса, то его вызов от класса и объекта не дадут
    нам того поведения, которого хотелось бы. Единственный
    вариант, как можно изменить поведение поиска по этой схеме,
    это определить __get__, и/или __set__ и __delete__, тогда
    сможем уходить вбок по веткам. Это и поможет нам изменить
    поведение при вызове. Как я понял, атрибуты с определенными
    вышеперечисленными magic методами и называются дескрипторами.
    Получается мы оборачиваем функцию в класс, у которого
    определены эти методы, тем самым изменяя поведении при вызове.

    Staticmethod функцию мы задаем без первого аргумента self, то есть
    как обычную функцию, но хотим, чтобы в нее не передавался
    class или object, что бы происходило по дефолту. Просто в
    __get__ возвращаем этот метод. И на ответвлении в instance,
    и в class, мы просто получим вызов __get__, что вызовет
    функцию.
    """
    class Inner:
        def __get__(self, instance, owner):
            return method
    return Inner()


def my_classmethod(method):
    """
    Classmethod по той же логике, только нам нужно частично
    применить к функции класс, а в __get__ это один из аргументов.
    """
    class Inner:
        def __get__(self, instance, owner):
            def partly_applied_method(*args, **kwargs):
                return method(owner, *args, **kwargs)
            return partly_applied_method
    return Inner()
