# Домашнее задание №6

**Дедлайн**: 11.27.2019 12:10

## Задачи

#### 1. Pepifize (1,5 балла)
Напишите метакласс `Pepifize`, который исправляет имена всех методов на змеиный_регистр и поддержите возможность помечать
методы, имена которых не должны быть изменены.

```python
class Example(metaclass=Pepifize, ignore=["theChadMethod"]):
    def theVirginMethod(self):
        print(50)

    def theChadMethod(self):
        print(100)

>>> c = Example()
>>> c.the_virgin_method()
50
>>> c.theChadMethod()
100
```


#### 2. WithFinals (2 балла)

Создайте метакласс `WithFinals`, а также опишите декоратор `final`, который будучи приписан к функции не позволяет 
переопределять ее в дочерних классах. Т.е. при попытке создать класс с переопределенной функцией, которая у родителя 
обозначена как `final`, должно генерироваться исключение. Не забудьте обработать ситуации, когда есть несколько родителей.
Подумайте про MRO! В непонятных ситуациях руководствуйтесь принципом, что допустимая ситуация - та, в которой в 
наследниках, при вызове метода, вызывается правильная реализация (см. пример 4) и 6) из заготовки).

#### 3. Singleton (2 балла)
Создайте расширенный метакласс `Singleton`. Подразумевается, что конструктор класса может вызываться с разными параметрами,
но при вызове от одинаковых параметров должны выдаваться одинаковые объекты. Т.е
```python
>>> a = A(2)
>>> b = A(2)
>>> c = A(3)

>>> a is b
True
>>> b is c
False
```

Реализовать возможность итерироваться по классам, к которым приписан метакласс `Singleton`. В качестве значений
итератор, который Вы напишите, должен возвращать уже созданные объекты класса. 
 

#### 4. View (2 балла)

Напишите метакласс `View`, добавляющий к классам метод `view`. При вызове `view` у объекта `obj`, метод за константное
время должен вернуть обертку над `obj`, через которую вы можете обращаться к атрибутам `obj`. При перезаписи или удалении
атрибута (через обертку) оригинальный объект `obj` изменяться не должен, но при обращении к атрибуту (через обертку)
должно использоваться обновленное значение, т.е. обертка должна хранить информацию об измененных атрибутах (но не о всех
остальных). Можно считать, что атрибут изменился, если изменился его `id`.

#### 5. UML (2,5 балла)

Создайте метакласс `UML`. В данном классе должен быть реализован статический метод `draw_uml(cls)`, который выводит
иерархию классов, вершиной которой является класс `cls` (у класса `cls` метаклассом должен быть указан `UML`, иначе
нужно вывести ошибку). Для простоты в данной задаче не нужно рассматривать множественное наследование. Например:

    >>> UML.draw_uml(A)
    A
        B
            C
            D
        E
        F
